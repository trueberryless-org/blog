---
title: Wie ich ein GitHub-Profil-README erstellt habe, das es nicht geben sollte
  (aber es existiert)
description: Ein tiefgehender Einblick in die technischen Herausforderungen und
  L√∂sungen hinter meinem GitHub-Profil-README, mit SVG-Manipulation,
  Automatisierung und einem dynamischen Bento-Grid.
date: 2025-02-05
tags:
  - Automation
  - GitHub
excerpt: Einen herausragenden <a class="gh-badge"
  href="https://github.com/github"><img src="https://github.com/github.png"
  alt="github" width="16" height="16"
  style="border-radius:9999px;vertical-align:middle;margin-right:0.4em;">GitHub</a>-Profil-README
  zu erstellen, geht nicht einfach darum, ein paar Abzeichen hinzuzuf√ºgen ‚Äî es
  geht darum, technische Grenzen zu √ºberschreiten. In dieser ausf√ºhrlichen
  Analyse untersuche ich die niedrigstufige SVG-Manipulation,
  HTML-zu-SVG-Konvertierung, Inline-Animationen und vollst√§ndige Automatisierung
  mit GitHub Actions, um zu erschaffen, was meiner Meinung nach eines der
  technisch fortschrittlichsten GitHub-READMEs ist. Von einem dynamischen
  Bento-Grid, das sich alle 5 Minuten aktualisiert, bis hin zum Einbetten von
  Live-SVGs ohne externe Anforderungen, hat dieses Projekt mein Profil in eine
  lebendige, sich selbst aktualisierende Pr√§sentation meiner Arbeit verwandelt.
  M√∂chtest du wissen, wie ich das gemacht habe? Lass uns eintauchen. üöÄ
authors:
  - trueberryless
  - ai
cover:
  alt: A beautiful cover image with the text "GitHub Profile"
  image: ../../../../../public/blog/technically-impressive-github-profile-readme.png

---

:::note
Lies die formellere Geschichte [hier](https://trueberryless.org/work/github-profile-readme/)
:::

## Der Anfang: Ein README, das wie ein Wikipedia-Dump aussah

Jede gro√üartige Geschichte beginnt mit einem Problem, und meines war simpel: Mein [GitHub-Profil](https://github.com/trueberryless) README war ein komplettes Chaos. Es war lang. Es hatte zu viel Text. Es war √ºberf√ºllt mit Abzeichen ‚Äî so viele, dass es aussah, als w√ºrde ich jede m√∂gliche Internet-Troph√§e horten. Hackathons, GitHub-Beitr√§ge, Astro, roadmap.sh ‚Äî wenn es ein Abzeichen gab, hatte ich es.

Zuerst dachte ich, das w√§re in Ordnung. Es zeigte doch alles √ºber mich, oder? Aber eines Tages sah ich es an und erkannte:

> Das ist nicht stylisch. Das ist ein chaotisches Desaster.

Ich brauchte etwas Neues. Etwas Sauberes. Etwas Visuell Beeindruckendes. Ich wollte ein **Bento-Grid**, das die Leute dazu bringt, stehen zu bleiben und es zu bewundern, anstatt verwirrt weiterzuscrollen. Ein Design, das so gut umgesetzt ist, dass jeder, der es sieht, sofort selbst eines haben m√∂chte.

Das war der Traum. Jetzt musste ich ihn nur noch realisieren.

## Phase 1: Der HTML-Traum (und Markdown-Alptraum)

Der erste Schritt war einfach: mein perfektes Profil in HTML und CSS entwerfen. Und lass mich dir sagen, es sah fantastisch aus. Es hatte das perfekte Layout, sanfte Animationen und genau die richtige Balance zwischen Inhalt und Raum. Dann holte mich die Realit√§t ein. Das musste in *GitHub-flavored Markdown* funktionieren. Kein Problem, oder? Markdown unterst√ºtzt HTML! Also kopierte ich mein sch√∂nes HTML in mein README und klickte auf Speichern.

> [GitHub](https://github.com/github): *Auf keinen Fall.*

GitHubs Markdown [filtert zwar nicht viele HTML-Tags aus, aber entscheidende](https://github.github.com/gfm/#disallowed-raw-html-extension). Aus Sicherheitsgr√ºnden nat√ºrlich (und ich respektiere das, GitHub, wirklich ‚ù§Ô∏è), aber das bedeutete, dass mein perfektes Design v√∂llig **unbrauchbar** war.

Ich versuchte, es anzupassen. Nicht unterst√ºtzte Tags durch solche zu ersetzen, die funktionierten. Vielleicht konnte ich etwas davon retten? *Nein.* Die Einschr√§nkungen von Markdown machten mein Traumlayout unm√∂glich.

## Phase 2: Das "Einfach ein Python-Skript verwenden"-Kompromiss

Wenn im Zweifel, automatisieren. Wenn ich mein HTML nicht direkt einf√ºgen konnte, vielleicht konnte ich etwas Dynamisches mit einem Skript generieren? Also bastelte ich ein Python-Skript, um mein neuestes GitHub-Repository abzurufen und in mein README einzuf√ºgen. Hier ein paar zuf√§llige Bytes, die manche als Python-Code bezeichnen w√ºrden:

```python collapse={1-22} showLineNumbers=false
import requests

github_username = "yourusername"
repos_url = f"https://api.github.com/users/{github_username}/repos?sort=pushed"

response = requests.get(repos_url)
repos = response.json()

latest_repo = repos[0]["name"] if repos else "No repositories found."

with open("README.md", "r") as file:
    readme_content = file.readlines()

new_content = []
for line in readme_content:
    if "<!--LATEST_REPO-->" in line:
        new_content.append(f"- Latest Repo: [{latest_repo}](https://github.com/{github_username}/{latest_repo})\n")
    else:
        new_content.append(line)

with open("README.md", "w") as file:
    file.writelines(new_content)
```

Das schien ein Schritt in die richtige Richtung zu sein. Es war automatisiert. Es war funktional. Aber es l√∂ste nicht mein eigentliches Problem. üò¢

Hier ging es nicht um dynamischen Inhalt ‚Äì es ging um *Design*. Und kein Python-Skript w√ºrde Markdown sch√∂n machen.

## Phase 3: "Na gut, ich benutze einfach einen Screenshot" (Tiefpunkt)

An diesem Punkt war ich verzweifelt. Ich zog das Undenkbare in Betracht: *einfach einen Screenshot des HTMLs machen und ihn als Bild in mein README einf√ºgen.* Es war eine brachiale Methode. Es war faul. Es war... effektiv?

F√ºr einen Moment dachte ich tats√§chlich daran, es zu tun. Aber ich wusste tief in mir, dass ich mir nie vergeben w√ºrde, wenn ich dies als endg√ºltige L√∂sung akzeptieren w√ºrde.

Nur zur Referenz, ich h√§tte [Puppeteer](https://www.npmjs.com/package/puppeteer) und [FFmpeg](https://www.ffmpeg.org/) verwendet ‚Äì keine Ahnung, was diese Tools machen.

## Phase 4: SVGs betreten die B√ºhne (Das Licht am Ende des Tunnels)

Ich gab den verfluchten Screenshot-Plan auf und suchte nach etwas Flexiblerem.

SVGs.

SVGs konnten skalieren, sie unterst√ºtzten sowohl Text als auch Bilder und ‚Äì am wichtigsten ‚Äì sie konnten **HTML einbetten**.

Also probierte ich so etwas aus:

```xml showLineNumbers=false
<svg width="800" height="400" xmlns="http://www.w3.org/2000/svg">
  <foreignObject width="100%" height="100%">
    <body xmlns="http://www.w3.org/1999/xhtml">
      <h1>Hello from HTML inside SVG!</h1>
    </body>
  </foreignObject>
</svg>
```

Vielversprechend! Das k√∂nnte tats√§chlich funktionieren!

Dann wurde ich mit anderen Dingen besch√§ftigt, verga√ü, es zu debuggen, und kehrte nie zu dieser Idee zur√ºck.

![Eine gute Idee verwerfen](../../../../../public/online-classes-throw-away.gif)

## Phase 5: SVGs innerhalb von SVGs innerhalb von SVGs (Inception-Level 100)

Als ich zum Projekt zur√ºckkehrte, war ich **entschlossen**, es zum Laufen zu bringen.

Ich erkannte, dass, wenn ich HTML nicht direkt in Markdown einbetten konnte, ich es f√§lschen konnte, indem ich verschachtelte SVGs verwendete. (√úbrigens ist dies massiv vereinfacht; der eigentliche Prozess dauerte Tage, die sich wie Wochen oder sogar Monate anf√ºhlten, aber ich wei√ü, dass du sowieso nicht alles lesen w√ºrdest, also, wen interessiert's?)

Und dann, nach stundenlanger Recherche, stie√ü ich auf eine lebensver√§ndernde Stack Overflow-Antwort:

[https://stackoverflow.com/a/65049620/22573601](https://stackoverflow.com/a/65049620/22573601)

Das f√ºhrte mich zur aktuellen L√∂sung:

1. Mein HTML-Layout in SVG umwandeln.
2. Alle Bilder in **Base64** codieren (weil GitHub-Markdown keine externen Bilder in einem SVG mit HTML l√§dt).
3. Dynamische SVGs (wie meine GitHub-Statistiken, Spotify-Status usw.) inline einf√ºgen.
4. Alles mit **GitHub Actions** automatisieren.

## Das gro√üe Finale: Das ultimative GitHub-Profil-README

* Ein elegantes Bento-Grid-Layout, perfekt in SVG strukturiert.
* Ein Live-aktualisierender Spotify-Status, in SVG eingebettet.
* GitHub-Statistiken, dynamisch per Automatisierung eingef√ºgt.
* Vollst√§ndig responsiv, vollst√§ndig skalierbar und wahnsinnig komplex zu erstellen.

Es aktualisiert sich alle 5 Minuten selbst, l√§uft vollst√§ndig auf GitHub Actions und ist auf keine externen Dienste angewiesen. Es ist wundersch√∂n. Es ist effizient. Und vor allem ist es technisch absurd auf die bestm√∂gliche Weise.

Schau dir zu einem beliebigen Zeitpunkt ein spezifisches Beispiel des Endergebnisses an.

import { Image } from 'astro:assets'

<Image src={"https://raw.githubusercontent.com/trueberryless/trueberryless/7519c6f50094bdfd6fb47f610e6638ac8efdd6ad/html-wrapper.svg"} width={980} height={913} alt="Final result" data-zoom-off />

Nicht so schlecht im Vergleich zum [alten README.md](https://github.com/trueberryless/trueberryless/blob/5dce4ad0033b00829f8ec3756827057017447a65/README.md). Und bitte kommentiere nicht, warum ich K-Pop h√∂re! Es ist besser, als du denkst, glaube mir.

Schau dir die Live-Version auf meinem GitHub [trueberryless](https://github.com/trueberryless) an ‚Äî falls ich mich entscheide, es zu behalten... ‚Äî und hinterlasse ein Follow, wenn du schon dort bist und es dir gefallen hat! ‚ù§Ô∏è

***

## Abschlie√üende Gedanken: War es das wert?

Absolut.

Diese Reise war frustrierend, zeitaufwendig und mit mehr Hindernissen gespickt, als ich jemals erwartet h√§tte. Aber ich habe so viel √ºber SVGs, Markdown-Einschr√§nkungen, GitHub Actions und Automatisierung gelernt.

W√ºrde ich es wieder tun? Definitiv.

W√ºrde ich es empfehlen? Nur wenn du extrem viel Geduld hast. üòÖ

Aber am Ende habe ich ein [GitHub](https://github.com/github)-Profil-README erstellt, das *nicht existieren sollte* ‚Äî aber es tut es. Und ich liebe es.
