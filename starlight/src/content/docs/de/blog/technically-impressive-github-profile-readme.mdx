---
title: Wie ich ein GitHub-Profil-README gebaut habe, das nicht existieren sollte
  (aber es tut)
description: Ein tiefgehender Einblick in die technischen Herausforderungen und
  L√∂sungen hinter meinem GitHub-Profil-README, mit Schwerpunkt auf
  SVG-Manipulation, Automatisierung und einem dynamischen Bento-Grid.
date: 2025-02-05
tags:
  - Automation
  - GitHub
excerpt: Ein herausragendes <a class="gh-badge"
  href="https://github.com/github"><img src="https://github.com/github.png"
  alt="github" />GitHub</a>-Profil-README zu erstellen, bedeutet nicht nur, ein
  paar Abzeichen hinzuzuf√ºgen ‚Äî es geht darum, technische Grenzen zu √ºberwinden.
  In diesem tiefgehenden Artikel erkunde ich grundlegende SVG-Manipulation,
  HTML-zu-SVG-Konvertierung, Inline-Animationen und vollst√§ndige Automatisierung
  mit GitHub Actions, um eines der technisch fortschrittlichsten GitHub-READMEs
  zu bauen. Von einem dynamischen Bento-Grid, das sich alle 5 Minuten
  aktualisiert, bis hin zur Einbettung von Live-SVGs ohne externe Anfragen ‚Äì
  dieses Projekt hat mein Profil in eine lebendige, sich selbst aktualisierende
  Pr√§sentation meiner Arbeit verwandelt. M√∂chtest du wissen, wie ich das gemacht
  habe? Lass es uns aufschl√ºsseln. üöÄ
authors:
  - trueberryless
  - ai
cover:
  alt: A beautiful cover image with the text "GitHub Profile"
  image: ../../../../../public/blog/technically-impressive-github-profile-readme.png

---

:::note
Lies die formellere Geschichte [hier](https://trueberryless.org/work/github-profile-readme/)
:::

## Der Anfang: Ein README, das wie ein Wikipedia-Dump aussah

Jede gro√üartige Geschichte beginnt mit einem Problem, und meines war einfach: Mein [GitHub-Profil](https://github.com/trueberryless) README war ein komplettes Chaos. Es war lang. Es hatte zu viel Text. Es war √ºberf√ºllt mit Abzeichen ‚Äî so viele, dass es aussah, als w√ºrde ich jede m√∂gliche Internet-Troph√§e horten. Hackathons, GitHub-Beitr√§ge, Astro, roadmap.sh ‚Äî wenn es ein Abzeichen gab, hatte ich es.

Am Anfang dachte ich, das w√§re in Ordnung. Es zeigte schlie√ülich alles √ºber mich, oder? Aber eines Tages sah ich es an und stellte fest:

> Das ist nicht stilvoll. Das ist ein √ºberladenes Desaster.

Ich brauchte etwas Neues. Etwas Sauberes. Etwas Visuell Beeindruckendes. Ich wollte ein **Bento-Grid**, das die Leute dazu bringt, stehen zu bleiben und es zu bewundern, anstatt verwirrt daran vorbeizuscrollen. Ein Design, das so gut ausgef√ºhrt ist, dass jeder, der es sieht, sofort eines f√ºr sich haben wollte.

Das war der Traum. Jetzt musste ich ihn nur noch realisieren.

## Phase 1: Der HTML-Traum (und Markdown-Albtraum)

Der erste Schritt war einfach: Entwerfen meines perfekten Profils in HTML und CSS. Und ich kann dir sagen, es sah unglaublich aus. Es hatte das perfekte Layout, sanfte Animationen und genau das richtige Gleichgewicht zwischen Inhalt und Raum. Dann kam die Realit√§t. Dies musste innerhalb von *GitHub-Flavored Markdown* funktionieren. Kein Problem, oder? Markdown unterst√ºtzt HTML! Also kopierte ich mein wundersch√∂nes HTML in mein README und dr√ºckte Speichern.

> [GitHub](https://github.com/github): *Absolut nicht.*

GitHubs Markdown [entfernt zwar keine gro√üe Anzahl von HTML-Tags, aber wichtige](https://github.github.com/gfm/#disallowed-raw-html-extension). Aus Sicherheitsgr√ºnden nat√ºrlich (und ich respektiere das vollkommen, GitHub, wirklich ‚ù§Ô∏è), aber das bedeutete, dass mein perfektes Design komplett **unbrauchbar** war.

Ich versuchte, es anzupassen. Ungest√ºtzte Tags durch solche zu ersetzen, die funktionierten. Vielleicht k√∂nnte ich etwas davon retten? *Nein*. Die Einschr√§nkungen von Markdown bedeuteten, dass mein Traum-Layout unm√∂glich war.

## Phase 2: Der "Einfach Ein Python-Skript Benutzen"-Kompromiss

Wenn man unsicher ist, automatisieren. Wenn ich mein HTML nicht direkt einf√ºgen konnte, konnte ich vielleicht etwas Dynamisches mit einem Skript erstellen? Also bastelte ich ein Python-Skript, das mein neuestes GitHub-Repository abruft und in mein README einf√ºgt. Hier einfach ein paar zuf√§llige Bytes, die manche als Python-Code bezeichnen:

```python collapse={1-22} showLineNumbers=false
import requests

github_username = "yourusername"
repos_url = f"https://api.github.com/users/{github_username}/repos?sort=pushed"

response = requests.get(repos_url)
repos = response.json()

latest_repo = repos[0]["name"] if repos else "No repositories found."

with open("README.md", "r") as file:
    readme_content = file.readlines()

new_content = []
for line in readme_content:
    if "<!--LATEST_REPO-->" in line:
        new_content.append(f"- Latest Repo: [{latest_repo}](https://github.com/{github_username}/{latest_repo})\n")
    else:
        new_content.append(line)

with open("README.md", "w") as file:
    file.writelines(new_content)
```

Das schien ein Schritt in die richtige Richtung zu sein. Es war automatisiert. Es funktionierte. Aber es l√∂ste mein eigentliches Problem nicht. üò¢

Es ging nicht um dynamischen Inhalt ‚Äî es ging um *Design*. Und kein Skript der Welt konnte Markdown sch√∂n machen.

## Phase 3: "Na Gut, Ich Nehme Einfach Einen Screenshot" (Tiefpunkt)

Zu diesem Zeitpunkt war ich verzweifelt. Ich dachte an das Undenkbare: *Einfach einen Screenshot vom HTML machen und ihn als Bild in mein README einf√ºgen.* Es war ein brutaler Ansatz. Es war faul. Es war... effektiv?

Einen Moment lang dachte ich tats√§chlich dar√ºber nach, es zu tun. Aber tief im Inneren wusste ich, dass ich mir nie verzeihen w√ºrde, wenn ich das als endg√ºltige L√∂sung akzeptieren w√ºrde.

Zur Referenz h√§tte ich [Puppeteer](https://www.npmjs.com/package/puppeteer) und [FFmpeg](https://www.ffmpeg.org/) verwendet ‚Äî keine Ahnung, was diese Tools sind.

## Phase 4: SVGs treten auf den Plan (Das Licht am Ende des Tunnels)

Ich lie√ü den verfluchten Screenshot-Plan fallen und suchte nach etwas Flexiblerem.

SVGs.

SVGs konnten skalieren, sie unterst√ºtzten sowohl Text als auch Bilder, und ‚Äî was am wichtigsten war ‚Äî sie konnten **HTML innerhalb von ihnen einbetten**.

Also versuchte ich etwas wie das:

```xml showLineNumbers=false
<svg width="800" height="400" xmlns="http://www.w3.org/2000/svg">
  <foreignObject width="100%" height="100%">
    <body xmlns="http://www.w3.org/1999/xhtml">
      <h1>Hello from HTML inside SVG!</h1>
    </body>
  </foreignObject>
</svg>
```

Vielversprechend! Das k√∂nnte tats√§chlich funktionieren!

Dann wurde ich mit anderen Dingen besch√§ftigt, verga√ü, es zu debuggen, und kehrte nie zu dieser Idee zur√ºck.

![Eine gute Idee verwerfen](../../../../../../public/online-classes-throw-away.gif)

## Phase 5: SVGs in SVGs in SVGs (Inception-Stufe 100)

Als ich zum Projekt zur√ºckkehrte, war ich **entschlossen**, es zum Laufen zu bringen.

Ich stellte fest, dass ich, wenn ich HTML nicht direkt in Markdown einbetten konnte, es durch verschachtelte SVGs vort√§uschen konnte. (√úbrigens ist das massiv vereinfacht; der eigentliche Prozess dauerte Tage, die sich wie Wochen anf√ºhlten, wenn nicht Monate, aber ich wei√ü, dass du sowieso nichts davon lesen w√ºrdest, also wen interessiert's?)

Und dann, nach Stunden der Recherche, stie√ü ich auf eine lebensver√§ndernde Stack Overflow-Antwort:

[https://stackoverflow.com/a/65049620/22573601](https://stackoverflow.com/a/65049620/22573601)

Das f√ºhrte mich zur aktuellen L√∂sung:

1. Mein HTML-Layout nach SVG konvertieren.
2. Alle Bilder in **Base64** codieren (da GitHub-Markdown keine externen Bilder in einem SVG mit HTML l√§dt).
3. Dynamische SVGs einbetten (wie meine GitHub-Statistiken, Spotify-Status usw.).
4. Alles mit **GitHub Actions** automatisieren.

## Das gro√üe Finale: Das ultimative GitHub-Profil-README

* Ein schlankes Bento-Grid-Layout, perfekt in SVG strukturiert.
* Ein live-aktualisierender Spotify-Status, in SVG eingebettet.
* GitHub-Statistiken, dynamisch √ºber Automatisierung eingef√ºgt.
* Vollst√§ndig responsiv, vollst√§ndig skalierbar und vollkommen verr√ºckt zu erstellen.

Es aktualisiert sich alle 5 Minuten selbst, l√§uft vollst√§ndig √ºber GitHub Actions und ist unabh√§ngig von externen Diensten. Es ist wundersch√∂n. Es ist effizient. Und am wichtigsten, es ist technisch absurd auf die beste Art und Weise.

Schauen Sie sich ein konkretes Beispiel der Endergebnisse irgendwann in der Vergangenheit an.

import { Image } from 'astro:assets'

<Image src={"https://raw.githubusercontent.com/trueberryless/trueberryless/7519c6f50094bdfd6fb47f610e6638ac8efdd6ad/html-wrapper.svg"} width={980} height={913} alt="Final result" data-zoom-off />

Das ist nicht schlecht im Vergleich zum [alten README.md](https://github.com/trueberryless/trueberryless/blob/5dce4ad0033b00829f8ec3756827057017447a65/README.md). Und kommentiere nicht, warum ich K-Pop h√∂re! Es ist besser, als du denkst, glaub mir.

Sieh dir die Live-Version auf meinem GitHub [trueberryless](https://github.com/trueberryless) an ‚Äî falls ich beschlossen habe, sie zu behalten... ‚Äî und folge mir, wenn du schon da bist, falls dir das Lesen gefallen hat! ‚ù§Ô∏è

***

## Abschlie√üende Gedanken: War es das wert?

Absolut.

Diese Reise war frustrierend, zeitaufwendig und voller Hindernisse, mit denen ich nie gerechnet h√§tte. Aber ich habe so viel √ºber SVGs, die Einschr√§nkungen von Markdown, GitHub Actions und Automatisierung gelernt.

W√ºrde ich es wieder tun? Definitiv.

W√ºrde ich es empfehlen? Nur, wenn du eine Menge Geduld hast. üòÖ

Aber am Ende habe ich ein [GitHub](https://github.com/github)-Profil-README erstellt, das *nicht existieren sollte* ‚Äî aber es existiert. Und ich liebe es.
