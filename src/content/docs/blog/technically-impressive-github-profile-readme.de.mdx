---
title: Wie ich ein GitHub-Profil-README erstellt habe, das es eigentlich nicht
  geben sollte (aber es gibt es)
description: Ein tiefgehender Einblick in die technischen Herausforderungen und
  L√∂sungen hinter meinem GitHub-Profil-README, mit Schwerpunkt auf
  SVG-Manipulation, Automatisierung und einem dynamischen Bento-Grid.
date: 2025-02-05
tags:
  - Automation
  - GitHub
excerpt: Ein herausragendes <a class="gh-badge"
  href="https://github.com/github"><img src="https://github.com/github.png"
  alt="github" />GitHub</a>-Profil-README zu erstellen, bedeutet nicht nur, ein
  paar Abzeichen hinzuzuf√ºgen ‚Äî es geht darum, technische Grenzen zu
  √ºberschreiten. In diesem tiefgehenden Einblick erkunde ich
  Low-Level-SVG-Manipulation, HTML-zu-SVG-Konvertierung, Inline-Animationen und
  vollst√§ndige Automatisierung mit GitHub Actions, um das vielleicht technisch
  fortschrittlichste GitHub-README zu erstellen. Von einem dynamischen
  Bento-Grid, das alle 5 Minuten aktualisiert wird, bis hin zum Einbetten von
  Live-SVGs ohne externe Anfragen hat dieses Projekt mein Profil in eine
  lebendige, sich selbst aktualisierende Pr√§sentation meiner Arbeit verwandelt.
  Neugierig, wie ich das gemacht habe? Lass uns loslegen. üöÄ
authors:
  - trueberryless
  - ai
cover:
  alt: Overhead perspective of a soccer field with two prominent lines delineating
    the field boundaries.
  image: ../../../../public/blog/technically-impressive-github-profile-readme.jpg

---

:::note
Lies die formellere Geschichte [hier](/blog/github-profile-readme/)
:::

## Der Anfang: Ein README, das wie ein Wikipedia-Dump aussah

Jede gro√üartige Geschichte beginnt mit einem Problem, und meines war einfach: Mein [GitHub-Profil](https://github.com/trueberryless) README war ein komplettes Chaos. Es war lang. Es hatte zu viel Text. Es war √ºberf√ºllt mit Abzeichen ‚Äî so viele, dass es aussah, als w√ºrde ich jede m√∂gliche Internet-Troph√§e horten. Hackathons, GitHub-Beitr√§ge, Astro, roadmap.sh ‚Äî wenn es ein Abzeichen gab, hatte ich es.

Am Anfang dachte ich, das w√§re in Ordnung. Es zeigte schlie√ülich alles √ºber mich, oder? Aber eines Tages sah ich es an und stellte fest:

> Das ist nicht stilvoll. Das ist ein √ºberladenes Desaster.

Ich brauchte etwas Neues. Etwas Sauberes. Etwas Visuell Beeindruckendes. Ich wollte ein **Bento-Grid**, das die Leute dazu bringt, stehen zu bleiben und es zu bewundern, anstatt verwirrt daran vorbeizuscrollen. Ein Design, das so gut ausgef√ºhrt ist, dass jeder, der es sieht, sofort eines f√ºr sich haben wollte.

Das war der Traum. Jetzt musste ich ihn nur noch realisieren.

## Phase 1: Der HTML-Traum (und Markdown-Albtraum)

Der erste Schritt war einfach: Entwerfen meines perfekten Profils in HTML und CSS. Und ich kann dir sagen, es sah unglaublich aus. Es hatte das perfekte Layout, sanfte Animationen und genau das richtige Gleichgewicht zwischen Inhalt und Raum. Dann kam die Realit√§t. Dies musste innerhalb von *GitHub-Flavored Markdown* funktionieren. Kein Problem, oder? Markdown unterst√ºtzt HTML! Also kopierte ich mein wundersch√∂nes HTML in mein README und dr√ºckte Speichern.

> [GitHub](https://github.com/github): *Absolut nicht.*

Die GitHub-Markdown [entfernt nicht eine riesige Anzahl von HTML-Tags, aber wichtige](https://github.github.com/gfm/#disallowed-raw-html-extension). Aus Sicherheitsgr√ºnden nat√ºrlich (und das respektiere ich vollkommen, GitHub, wirklich ‚ù§Ô∏è), aber das bedeutete, dass mein perfektes Design komplett **unbrauchbar** war.

Ich habe versucht, es anzupassen. Nicht unterst√ºtzte Tags durch funktionierende zu ersetzen. Vielleicht konnte ich etwas retten? *Nein*. Die Einschr√§nkungen von Markdown machten mein Traum-Layout unm√∂glich.

## Phase 2: Der "Einfach Ein Python-Skript Benutzen"-Kompromiss

Wenn du dir unsicher bist, automatisiere es. Wenn ich mein HTML nicht direkt einf√ºgen konnte, vielleicht konnte ich etwas Dynamisches mit einem Skript generieren? Also habe ich ein Python-Skript zusammengestellt, um mein neuestes GitHub-Repository abzurufen und in mein README einzuf√ºgen. Ich lasse hier einfach ein paar zuf√§llige Bytes, die einige als Python-Code bezeichnen k√∂nnten:

```python collapse={1-22} showLineNumbers=false
import requests

github_username = "yourusername"
repos_url = f"https://api.github.com/users/{github_username}/repos?sort=pushed"

response = requests.get(repos_url)
repos = response.json()

latest_repo = repos[0]["name"] if repos else "No repositories found."

with open("README.md", "r") as file:
    readme_content = file.readlines()

new_content = []
for line in readme_content:
    if "<!--LATEST_REPO-->" in line:
        new_content.append(f"- Latest Repo: [{latest_repo}](https://github.com/{github_username}/{latest_repo})\n")
    else:
        new_content.append(line)

with open("README.md", "w") as file:
    file.writelines(new_content)
```

Das schien ein Schritt in die richtige Richtung zu sein. Es war automatisiert. Es funktionierte. Aber es l√∂ste nicht mein eigentliches Problem. üò¢

Es ging nicht um dynamischen Inhalt ‚Äî es ging um *Design*. Und keine Menge Python-Scripting w√ºrde Markdown sch√∂n aussehen lassen.

## Phase 3: "Na Gut, Ich Nehme Einfach Einen Screenshot" (Tiefpunkt)

Zu diesem Zeitpunkt war ich verzweifelt. Ich dachte an das Undenkbare: *Einfach einen Screenshot vom HTML machen und ihn als Bild in mein README einf√ºgen.* Es war ein brutaler Ansatz. Es war faul. Es war... effektiv?

Einen Moment lang dachte ich tats√§chlich dar√ºber nach, es zu tun. Aber tief im Inneren wusste ich, dass ich mir nie verzeihen w√ºrde, wenn ich das als endg√ºltige L√∂sung akzeptieren w√ºrde.

Zur Referenz h√§tte ich [Puppeteer](https://www.npmjs.com/package/puppeteer) und [FFmpeg](https://www.ffmpeg.org/) verwendet ‚Äî keine Ahnung, was diese Tools sind.

## Phase 4: SVGs treten auf den Plan (Das Licht am Ende des Tunnels)

Ich lie√ü den verfluchten Screenshot-Plan fallen und suchte nach etwas Flexiblerem.

SVGs.

SVGs konnten skalieren, sie unterst√ºtzten sowohl Text als auch Bilder, und ‚Äî was am wichtigsten war ‚Äî sie konnten **HTML innerhalb von ihnen einbetten**.

Also versuchte ich etwas wie das:

```xml showLineNumbers=false
<svg width="800" height="400" xmlns="http://www.w3.org/2000/svg">
  <foreignObject width="100%" height="100%">
    <body xmlns="http://www.w3.org/1999/xhtml">
      <h1>Hello from HTML inside SVG!</h1>
    </body>
  </foreignObject>
</svg>
```

Vielversprechend! Das k√∂nnte tats√§chlich funktionieren!

Dann wurde ich mit anderen Dingen besch√§ftigt, verga√ü, es zu debuggen, und kehrte nie zu dieser Idee zur√ºck.

![Eine gute Idee wegwerfen](../../../assets/blog/technically-impressive-github-profile-readme/online-classes-throw-away.gif)

## Phase 5: SVGs in SVGs in SVGs (Inception-Stufe 100)

Als ich zum Projekt zur√ºckkehrte, war ich **entschlossen**, es zum Laufen zu bringen.

Mir wurde klar, dass, wenn ich HTML nicht direkt in Markdown einf√ºgen konnte, ich es vort√§uschen konnte, indem ich verschachtelte SVGs verwendete. (√úbrigens ist dies stark vereinfacht; der tats√§chliche Prozess dauerte Tage, die sich wie Wochen, wenn nicht Monate anf√ºhlten, aber ich wei√ü, dass ihr das sowieso nicht alles lesen w√ºrdet, also wen interessiert's?)

Und dann, nach Stunden der Recherche, stie√ü ich auf eine lebensver√§ndernde Stack Overflow-Antwort:

[https://stackoverflow.com/a/65049620/22573601](https://stackoverflow.com/a/65049620/22573601)

Das f√ºhrte mich zur aktuellen L√∂sung:

1. Mein HTML-Layout nach SVG konvertieren.
2. Alle Bilder in **Base64** kodieren (da GitHub Markdown keine externen Bilder innerhalb eines SVG mit HTML l√§dt).
3. Dynamische SVGs einbetten (wie meine GitHub-Statistiken, Spotify-Status usw.).
4. Alles mit **GitHub Actions** automatisieren.

## Das gro√üe Finale: Das ultimative GitHub-Profil-README

* Ein schlankes Bento-Grid-Layout, perfekt in SVG strukturiert.
* Ein live-aktualisierender Spotify-Status, in SVG eingebettet.
* GitHub-Statistiken, dynamisch √ºber Automatisierung eingef√ºgt.
* Vollst√§ndig responsiv, vollst√§ndig skalierbar und vollkommen verr√ºckt zu erstellen.

Es aktualisiert sich alle 5 Minuten, l√§uft vollst√§ndig auf GitHub Actions und ist nicht auf externe Dienste angewiesen. Es ist wundersch√∂n. Es ist effizient. Und vor allem ist es technisch absurd im besten Sinne.

Schauen Sie sich ein konkretes Beispiel der Endergebnisse irgendwann in der Vergangenheit an.

import { Image } from 'astro:assets'

<Image src={"https://raw.githubusercontent.com/trueberryless/trueberryless/7519c6f50094bdfd6fb47f610e6638ac8efdd6ad/html-wrapper.svg"} width={980} height={913} alt="Final result" data-zoom-off />

Ist das nicht schlecht im Vergleich zum [alten README.md](https://github.com/trueberryless/trueberryless/blob/5dce4ad0033b00829f8ec3756827057017447a65/README.md). Und kommentier bitte nicht, warum ich K-Pop h√∂re! Es ist besser, als du denkst, glaub mir.

Sieh dir die Live-Version auf meinem GitHub [trueberryless](https://github.com/trueberryless) an ‚Äî falls ich beschlossen habe, sie zu behalten... ‚Äî und folge mir, wenn du schon da bist, falls dir das Lesen gefallen hat! ‚ù§Ô∏è

***

## Abschlie√üende Gedanken: War es das wert?

Absolut.

Diese Reise war frustrierend, zeitaufwendig und voller Hindernisse, mit denen ich nie gerechnet h√§tte. Aber ich habe so viel √ºber SVGs, die Einschr√§nkungen von Markdown, GitHub Actions und Automatisierung gelernt.

W√ºrde ich es wieder tun? Definitiv.

W√ºrde ich es empfehlen? Nur, wenn du eine Menge Geduld hast. üòÖ

Aber am Ende habe ich ein [GitHub](https://github.com/github)-Profil-README erstellt, das *eigentlich nicht existieren sollte* ‚Äî aber es existiert. Und ich liebe es.
